<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=generator content="Hugo 0.121.2"><title>Combined-Linux: ein Image für viele Geräte &#183; Holger Schurig's Computer Calisthenics & Orthodontia</title>
<link rel=stylesheet href=../../css/pure-min.css><!--[if lte IE 8]><link rel=stylesheet href=../../css/grids-responsive-old-ie-min.css><![endif]--><!--[if gt IE 8]><!--><link rel=stylesheet href=../../css/grids-responsive-min.css><!--<![endif]--><!--[if lte IE 8]><link rel=stylesheet href=../../css/side-menu-old-ie.css><![endif]--><!--[if gt IE 8]><!--><link rel=stylesheet href=../../css/side-menu.css><!--<![endif]--><link rel=stylesheet href=../../css/blackburn.css><link rel=stylesheet href=../../css/all.min.css><link rel=alternate type=application/rss+xml title="Holger Schurig's Computer Calisthenics & Orthodontia" href=../../index.xml><link rel="shortcut icon" href=../../img/favicon.ico type=image/x-icon></head><body><div id=layout><a href=#menu id=menuLink class=menu-link><span></span></a><div id=menu><div class=pure-menu><ul class=pure-menu-list><li class=pure-menu-item><a class=pure-menu-link href=../../><i class='fa fa-home fa-fw'></i>Home</a></li><li class=pure-menu-item><a class=pure-menu-link href=../../en/><i class='fa fa-list fa-fw'></i>Articles</a></li><li class=pure-menu-item><a class=pure-menu-link href=../../de/><i class='fa fa-list fa-fw'></i>Beiträge</a></li><li class=pure-menu-item><a class=pure-menu-link href=../../categories/><i class='fa fa-folder fa-fw'></i>Categories</a></li><li class=pure-menu-item><a class=pure-menu-link href=../../tags/><i class='fa fa-tags fa-fw'></i>Tags</a></li><li class=pure-menu-item><a class=pure-menu-link href=../../impressum/><i class='fa fa-phone fa-fw'></i>Impressum</a></li></ul></div></div><div id=main><div class=header><h1>Combined-Linux: ein Image für viele Geräte</h1><h2></h2></div><div class=content><p>Hier ging es darum, ein und dasselbe Linux-Image auf eine Vielzahl von Geräte zu portieren.<br></p><p>Dies stand im Gegensatz zu den Windows- und Windows-Embedded-Images. Hier wurde<br>für jedes Gerät ein eigenes Image erstellt. Gab es eine Innovation, mussten alle<br>diese Image jeweils neu erstellt werden &mdash; ein zeitraubender Prozess.<br></p><p>Ich wollte ein &ldquo;Combined Linux&rdquo; machen: eine Image, das alle Features in sich<br>enthält. Das man überall installieren kann. Das die Hardware erkennt und die<br>jeweils eingebaute Hardware passend anspricht und zur Verfügung stellt.<br></p><div class="ox-hugo-toc toc"><div class=heading>Table of Contents</div><ul><li><a href=#projekt-info>Projekt-Info</a></li><li><a href=#basis-debian-linux>Basis: Debian-Linux</a></li><li><a href=#anpassen-dot-dot-dot-aber-an-was>Anpassen &mldr; aber an was?</a><ul><li><a href=#stapler-terminals>Stapler-Terminals</a></li><li><a href=#tragbare-terminals>Tragbare Terminals</a></li><li><a href=#fahrzeug-computer>Fahrzeug-Computer</a></li><li><a href=#industrie-panel-pcs>Industrie-Panel-PCs</a></li></ul></li><li><a href=#hardware-erkennen>Hardware erkennen</a><ul><li><a href=#string-im-bios>String im BIOS</a></li><li><a href=#dmi>DMI</a></li><li><a href=#pci-ids-testen>PCI-IDs testen</a></li></ul></li><li><a href=#userspace>Userspace</a><ul><li><a href=#gui-anpassen>GUI anpassen</a></li><li><a href=#daemons-anpassen>Daemons anpassen</a></li></ul></li><li><a href=#verwandte-projekte>Verwandte Projekte</a></li></ul></div><div class=job><p>In Beiträgen der Kategorie <a href=../../categories/job/>Job</a> trage ich Projekte zusammen, die ich im Rahmen<br>meiner beruflichen Karriere federführend durchgeführt habe. Ich gehe dabei mit<br>Absicht nicht allzusehr auf Details an: die Interessen meiner Arbeitgeber sollen<br>ja nicht berührt werden.<br></p></div><h2 id=projekt-info>Projekt-Info</h2><p>Idee: Kunden (das es Linux-Images geben sollte), ich (das man alle Gerätetypen<br>in ein Image kombinieren sollte)<br></p><p>Zuarbeit: Zusatz-Ideen kamen von PSS (Product Support Services), FAE (Field<br>Application Engineers), PMs (Produkt/Project Manager, allerdings eher wenig) und<br>auch direkt von Kunden<br></p><p>Umsetzung: ich<br></p><p>Nutzung: 2012 bis heute<br></p><p>Effizienzgewinn:<br></p><ul><li>ein Image statt über 20 Images erstellen ist ein erheblicher Zeitgewinn<br></li><li>(man könnte argumentieren, das es beim Test eine kombinatorische Explosion<br>gibt. Das ist aber nicht der Fall, da vor Auslieferung von Gerät+Linux-Image<br>dies sowieso von FAE und Kunden geprüft und dann in einer spezifischen<br>Hardware/Softwareversion freigegeben und festgezurrt wurde)<br></li></ul><h2 id=basis-debian-linux>Basis: Debian-Linux</h2><p>Basis war Debian-Linux.<br></p><p>Heutzutage ist Ubuntu viel bekannter, aber bei Projektstart war dies nicht der<br>Fall. Außerdem ist Ubuntu auf das Desktop-Metapher optimiert. In<br>Industrie-Anwendungen will man aber z.B. keinen Start-Button haben. Man möchte<br>(i.d.R.) nicht, das beim Einstecken eines USB-Sticks ein Dialog aufpoppt. Im<br>Prinzip braucht man überhaupt nichts aus der Desktop-Metapher.<br></p><p>Stattdessen möchte man fast immer nur einige einzige Anwendung haben, exclusiv,<br>im &ldquo;Kiosk-Modus&rdquo;. Also nicht abbrechbar und ohne Wechselmöglichkeit. Also warum<br>ein Icon haben, das man anklicken muss, wenn die Applikation auch direkt<br>gestartet werden kann?<br></p><p>Schließlich will niemand, das Lagerarbeiter Tetris spielen &mldr;<br></p><h2 id=anpassen-dot-dot-dot-aber-an-was>Anpassen &mldr; aber an was?</h2><p>Die unterstützten Geräte (siehe unten) habe unterschiedliche &mldr;<br></p><ul><li>Anzahl Ethernet-Karten: 0 bis 2<br></li><li>Anzahl WLAN-Karten: 0 bis 1<br></li><li>Anzahl WWAN-Karten (GSM, UMTS etc): 0 bis 1<br></li><li>Anzahl NFC-Interfaces: 0 bis 1<br></li><li>Anzahl Bluetooth-Interfaces: 0 bis 1<br></li><li>unterschiedliche Auflösungen<br></li><li>unterschiedliche Tasten auf der Frontplatte<br></li><li>unterschiedliche Touchscreen-Technologien (resistiv, kapazitiv) und Touchscreen-Controller-ICs<br></li><li>unterschiedliche Beleuchtungskonzepte (Backlight, Keyboard &mldr;)<br></li><li>unterschiedliche Barcode-Scanner (keine, Symbol, Intermec, Honeywell, seriell, Bluetooth)<br></li><li>&mldr; und viele Unterschiede mehr<br></li></ul><p>Jedoch sollte die Software im &ldquo;Combined-Linux&rdquo; Image sich dynamisch auf die<br>Gegenheiten anpassen, beispielsweise welche Einstellungsmöglichkeit im<br>&ldquo;<code>config</code>&rdquo; GUI-Programm angezeigt werden.<br></p><p>Hier Beispiele für die Geräteklassen:<br></p><h3 id=stapler-terminals>Stapler-Terminals</h3><p><figure><img src=./staplerterminals.jpg></figure><br></p><ul><li>IPC7 (DLoG)<br></li><li>MPC6 (DLoG)<br></li><li>MTC6 (DLoG)<br></li><li>MTC6 mit AMD CPU<br></li><li>DLT-V83 (DLoG)<br></li><li>DLT-V83 Atom (DLoG)<br></li><li>DLT-V83 Celeron (DLoG)<br></li><li>DLT-V83 Facelift (Advantech)<br></li><li>DLT-V83 i5 (DLoG)<br></li><li>DLT-V72 (DLoG)<br></li><li>DLT-V72 Facelift (Advantech)<br></li><li>DLT-V72 mit voller Tastatur (DLoG)<br></li><li>DLT-V73 x86 (Advantech)<br></li><li>DLT-V62 (Advantech)<br></li><li>DLT-M81 (Advantech)<br></li></ul><p>Werden in Stapler- oder Kommissionierfahrzeuge eingebaut. Manchmal auch in<br>Hochregal-Bedienfahrzeuge, Logistik-Hängebahnen, Portalkräne etc.<br></p><h3 id=tragbare-terminals>Tragbare Terminals</h3><p><figure><img src=./handterminals.jpg></figure><br></p><ul><li>DT362 (Digital Research)<br></li><li>S10A (Advantech)<br></li><li>PWS-770 (Advantech)<br></li><li>PWS-870 (Advantech)<br></li></ul><p>Diese Geräte nimmt man in die Hand und kann sich damit frei bewegen. Auf den<br>Fotos sieht man das nicht, aber sie haben einen eingebauten Barcode-Scanner.<br></p><h3 id=fahrzeug-computer>Fahrzeug-Computer</h3><p><figure><img src=./fahrzeugcomputer.jpg></figure><br></p><ul><li>TREK-753 (Advantech)<br></li></ul><p>Diese sind dazu gedacht, in KFZ eingebaut zu werden, beispielsweise in Bussen,<br>als Steuergerät für &ldquo;Vehicle Smart Displays&rdquo;. Aber mit Linux drauf kann man sie<br>auch für andere Dinge einsetzen &mldr;<br></p><h3 id=industrie-panel-pcs>Industrie-Panel-PCs</h3><p><figure><img src=./panelpcs.jpg></figure><br></p><ul><li>UTC-210 (Advantech)<br></li><li>UTC-520 (Advantech)<br></li></ul><p>Werden in der Industrie zum Anzeigen allgemeiner Informationen genutzt,<br>beispielsweise an den Fließbändern von Auto-Herstellern.<br></p><h2 id=hardware-erkennen>Hardware erkennen</h2><p>Man muß nun den Gerätetyp einwandfrei erkennen. Wie macht man das am besten, damit<br>man keine Falscherkennungen hat?<br></p><p><figure><img src=hwdetect.png></figure><br></p><h3 id=string-im-bios>String im BIOS</h3><p>Die von DLoG oder Advantech (sie haben DLoG aufgekauft) selbst produzierten Geräte<br>hatten im BIOS einen speziell formatieren String hinterlegt. Der hat das Gerät,<br>aber auch die Version des BIOS kodiert.<br></p><p>Eine Wildcard-Suche prüfte dann in einem definierten physikalischen Speicherbereich, ob<br>es einen String wie z.B. &ldquo;M6I??C??&rdquo; gibt.<br></p><p>Das hat ein Linux-Kernel-Modul gemacht, da hierbei einfach auf physikalischen<br>Speicher zugegriffen werden kann. Ein Linux-Userspace-Programm kann das zwar<br>auch, müsste aber als &ldquo;root&rdquo; laufen.<br></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>  // Mem start, length,  Wildcard + len, Device,  Human text
</span></span><span style=display:flex><span>  { 0x000f0000, 0xffffe, &#34;G6I??C??&#34;,  8, IS_DEVA, &#34;Device A&#34; },
</span></span><span style=display:flex><span>  { 0xfff40000, 0x80000, &#34;G6A??C??&#34;,  8, IS_DEVB, &#34;Device A mit AMD&#34; },
</span></span></code></pre></div><p>Das Kernelmodul wird automatisch geladen und stellt sein Ergebnis via<br>&ldquo;<code>/proc/...</code>&rdquo; Pseudo-Datei zur Verfügung. Darauf können alle Programme<br>zugreifen, &ldquo;root&rdquo; oder nicht.<br></p><p>Bei den Geräten, die einen BIOS-String haben, kamen wir auf 100% Erkennungsrate<br>und 0% Fehlerrate.<br></p><h3 id=dmi>DMI</h3><p>Leider gab es Hardware, bei der das nicht funktionierte: Geräte die nicht unter den<br>Einfluss von DLoG designed wurden (beispielsweise die Treks, die UTCs, die PWS).<br></p><p>Aber in einigen Fällen sind die Informationen des <a href=https://de.wikipedia.org/wiki/Desktop_Management_Interface>DMI</a> brauchbar. Als Kernel-Modul kommt<br>man da recht einfach dran:<br></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>  vendor  <span style=color:#f92672>=</span> <span style=color:#a6e22e>dmi_get_system_info</span>(DMI_SYS_VENDOR);
</span></span><span style=display:flex><span>  product <span style=color:#f92672>=</span> <span style=color:#a6e22e>dmi_get_system_info</span>(DMI_PRODUCT_NAME);
</span></span></code></pre></div><p>Das Ergebnis kann man gegen Soll-Werte vergleichen und weiß dann, auf welcher Hardware<br>man ist.<br></p><p>Bei den Geräten, die einen DMI-String haben, kamen wir auf 100% Erkennungsrate<br>und 0% Fehlerrate.<br></p><h3 id=pci-ids-testen>PCI-IDs testen</h3><p>Erstaunlicherweise gibt es viel DMIs, die schlecht gepflegt sind. Da steht dann<br>z.B. &ldquo;to be filled by O.E.M.&rdquo;, womit man nichts anfangen kann. Außer vielleicht<br>darauf schließen, das der Hersteller keine Liebe zum Detail hat und<br>unvollständige Arbeit abliefert.<br></p><p>Man braucht als leider eine Rückfalloption. Dazu dienten PCI-IDs. Im Linux-Userspace<br>kann man diese mit &ldquo;<code>lspci -nn</code>&rdquo; sehen &mdash; und selbstverständlich kommt ein<br></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>  // Host bridge
</span></span><span style=display:flex><span>  { 0x8086, 0x0a04, IS_DEVA | IS_DEVB },           // Intel Corporation Haswell-ULT DRAM Controller
</span></span><span style=display:flex><span>  { 0x8086, 0x0bf1, IS_DEVC },                     // Intel Corporation Atom Processor D2xxx DRAM Controller
</span></span><span style=display:flex><span>  { 0x8086, 0x0f00, IS_DEVD | IS_DEVE | IS_DEVF},  // Intel Corporation Atom Processor Z36xxx/Z37xxx Series SoC
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  // PCI Bridge
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  // SATA
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  // USB-Controller
</span></span><span style=display:flex><span>  ...
</span></span></code></pre></div><p>Wie man gut sieht, reicht die Host-Bridge 8086:0a04 nicht aus, um ein Gerät<br>eindeutig zu indentifizieren. Denn sie kommt auf mehreren Geräten vor.<br></p><p>Wenn man jedoch die Informationen der anderen PCI-IDs hinzufügt (mit &ldquo;&mldr;&rdquo;<br>angedeutet), klappt es evtl doch.<br></p><p>Damit konnte ich dann die Hardware-Erkennung für all die Geräte &ldquo;erschlagen&rdquo;,<br>die weder BIOS-Strings noch DMI-Strings hatten. Jedoch &mldr; wird das Image auf<br>einem unbekanntem Gerät ausgeführt, kann es Fehlerkennungen geben.<br></p><h2 id=userspace>Userspace</h2><h3 id=gui-anpassen>GUI anpassen</h3><p>Nachdem die Hardware einmal erkannt ist, ist es leicht, darauf zu reagieren.<br></p><p>Das &ldquo;<code>config</code>&rdquo; GUI ist in C++/Qt geschrieben.<br></p><p>Darauf aufsetzend wurden Funktionen definiert die mit &ldquo;<code>isXXX()</code>&rdquo; bzw &ldquo;<code>hasXXXX()</code>&rdquo;<br>anfangen. Die is-Funktionen prüfen auf eine Gerät, die has-Funktionen prüfen<br>auf eine Funktion (hat Bluetooth, hat Backlight, hat USB-Gerät XXXX:YYYY).<br></p><p>Dadurch ist das Anpassen, hier z.B. des grafischen Menüs, ziemlich einfach:<br></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    if (isDevA() || isDevE() || isDemo())
</span></span><span style=display:flex><span>        addIcon(tr(&#34;Backlight&#34;), &#34;:/images/backlight.svg&#34;, SLOT(clickedBacklight()) );
</span></span></code></pre></div><h3 id=daemons-anpassen>Daemons anpassen</h3><p>Auch Daemons müssen sich an die sehr unterschiedlicher Hardware anpassen. Dort<br>geht dies genauso einfach, hier am Beispiel des &ldquo;<code>scannerd</code>&rdquo;:<br></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    if (isDevA()) {
</span></span><span style=display:flex><span>        port = &#34;/dev/ttyS1&#34;;
</span></span><span style=display:flex><span>        serialReader = new ReadIntermec(port, 19200, this);
</span></span><span style=display:flex><span>        serialReconnect = true;
</span></span><span style=display:flex><span>    } else
</span></span><span style=display:flex><span>    if (isDevE()) {
</span></span><span style=display:flex><span>        port = &#34;/dev/ttyS1&#34;;
</span></span><span style=display:flex><span>        serialReader = new ReadHoneywell(port, 115200, this);
</span></span><span style=display:flex><span>        serialReconnect = true;
</span></span><span style=display:flex><span>    } else
</span></span></code></pre></div><h2 id=verwandte-projekte>Verwandte Projekte</h2><p>Die folgenden Projekte verwenden (teils abgewandelt) das Combined Image:<br></p><ul><li><a href=../../de/mkimage/>Automatische Image-Erstellung</a><br></li><li><a href=../../de/dynamischer-flashschutz/>Dynamischer Flash-Schutz</a><br></li><li>TODO(Artikel schreiben) Linux-Image auf Basis von i.MX& RISC Prozessor für den Tagebau<br></li><li>TODO(Artikel schreiben) Linux Restore Stick<br></li><li><a href=../../de/hwtester/>Hardware-Teststick für DLT-V83/DLT-V72</a><br></li><li>TODO(Artikel schreiben) Hardware-Teststick für DLT-V73<br></li><li>TODO(Artikel schreiben) Aufräumen in Fukushima<br></li></ul><div class=post-meta><div><i class="fa fa-copyright fa-fw"></i>
License: <a href=https://spdx.org/licenses/CC-BY-SA-4.0.html target=_blank>CC-BY-SA 4.0</a></div><div><i class="fa fa-calendar fa-fw"></i>
<time>2024-01-16</time></div><div><i class="fa fa-folder fa-fw"></i>
<a class=post-taxonomy-topic href=../../categories/job>job</a>
<a class=rss type=application/rss+xml href=../../categories/job/index.xml><span class="fa fa-rss">RSS</span></a></div><div><i class="fa fa-tags fa-fw"></i>
<a class=post-taxonomy-tag href=../../tags/qt>qt</a>
<a class=rss type=application/rss+xml href=../../tags/qt/index.xml><span class="fa fa-rss">RSS</span></a>
&nbsp;/
<a class=post-taxonomy-tag href=../../tags/c++>c++</a>
<a class=rss type=application/rss+xml href=../../tags/c++/index.xml><span class="fa fa-rss">RSS</span></a>
&nbsp;/
<a class=post-taxonomy-tag href=../../tags/linux>linux</a>
<a class=rss type=application/rss+xml href=../../tags/linux/index.xml><span class="fa fa-rss">RSS</span></a></div></div></div></div></div><script src=../../js/ui.js></script><script src=../../js/menus.js></script></body></html>