<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=generator content="Hugo 0.124.1"><title>&#183; Holger Schurig's Computer Calisthenics & Orthodontia</title>
<link rel=stylesheet href=../../../css/pure-min.css><!--[if lte IE 8]><link rel=stylesheet href=../../../css/grids-responsive-old-ie-min.css><![endif]--><!--[if gt IE 8]><!--><link rel=stylesheet href=../../../css/grids-responsive-min.css><!--<![endif]--><!--[if lte IE 8]><link rel=stylesheet href=../../../css/side-menu-old-ie.css><![endif]--><!--[if gt IE 8]><!--><link rel=stylesheet href=../../../css/side-menu.css><!--<![endif]--><link rel=stylesheet href=../../../css/blackburn.css><link rel=stylesheet href=../../../css/all.min.css><link rel=alternate type=application/rss+xml title="Holger Schurig's Computer Calisthenics & Orthodontia" href=../../../index.xml><link rel="shortcut icon" href=../../../img/favicon.ico type=image/x-icon></head><body><div id=layout><a href=#menu id=menuLink class=menu-link><span></span></a><div id=menu><div class=pure-menu><ul class=pure-menu-list><li class=pure-menu-item><a class=pure-menu-link href=../../../><i class='fa fa-home fa-fw'></i>Home</a></li><li class=pure-menu-item><a class=pure-menu-link href=../../../en/><i class='fa fa-list fa-fw'></i>Articles</a></li><li class=pure-menu-item><a class=pure-menu-link href=../../../de/><i class='fa fa-list fa-fw'></i>Beiträge</a></li><li class=pure-menu-item><a class=pure-menu-link href=../../../categories/><i class='fa fa-folder fa-fw'></i>Categories</a></li><li class=pure-menu-item><a class=pure-menu-link href=../../../tags/><i class='fa fa-tags fa-fw'></i>Tags</a></li><li class=pure-menu-item><a class=pure-menu-link href=../../../impressum/><i class='fa fa-phone fa-fw'></i>Impressum</a></li></ul></div></div><div id=main><div class=header><h1></h1><h2></h2></div><div class=content><div id=outline-container-headline-1 class=outline-2><h2 id=headline-1>Combined-Linux: ein Image für viele Geräte</h2><div id=outline-text-headline-1 class=outline-text-2><p>Hier ging es darum, ein und dasselbe Linux-Image auf eine Vielzahl von Geräte zu portieren.</p><p>Dies stand im Gegensatz zu den Windows- und Windows-Embedded-Images. Hier wurde
für jedes Gerät ein eigenes Image erstellt. Gab es eine Innovation, mussten alle
diese Image jeweils neu erstellt werden — ein zeitraubender Prozess.</p><p>Ich wollte ein "Combined Linux" machen: eine Image, das alle Features in sich
enthält. Das man überall installieren kann. Das die Hardware erkennt und die
jeweils eingebaute Hardware passend anspricht und zur Verfügung stellt.</p><nav><ul><li><a href=#headline-1>Combined-Linux: ein Image für viele Geräte</a><ul><li><a href=#headline-2>Projekt-Info</a></li><li><a href=#headline-3>Basis: Debian-Linux</a></li><li><a href=#headline-4>Anpassen … aber an was?</a></li><li><a href=#headline-9>Hardware erkennen</a></li><li><a href=#headline-13>Userspace</a></li><li><a href=#headline-16>Verwandte Projekte</a></li></ul></li></ul></nav><div class=job-block><p>In Beiträgen der Kategorie <a href=../../../categories/job/>Job</a> trage ich Projekte zusammen, die ich im Rahmen
meiner beruflichen Karriere federführend durchgeführt habe. Ich gehe dabei mit
Absicht nicht allzusehr auf Details an: die Interessen meiner Arbeitgeber sollen
ja nicht berührt werden.</p></div><div id=outline-container-headline-2 class=outline-3><h3 id=headline-2>Projekt-Info</h3><div id=outline-text-headline-2 class=outline-text-3><p>Idee: Kunden (das es Linux-Images geben sollte), ich (das man alle Gerätetypen
in ein Image kombinieren sollte)</p><p>Zuarbeit: Zusatz-Ideen kamen von PSS (Product Support Services), FAE (Field
Application Engineers), PMs (Produkt/Project Manager, allerdings eher wenig) und
auch direkt von Kunden</p><p>Umsetzung: ich</p><p>Nutzung: 2012 bis heute</p><p>Effizienzgewinn:</p><ul><li>ein Image statt über 20 Images erstellen ist ein erheblicher Zeitgewinn</li><li>(man könnte argumentieren, das es beim Test eine kombinatorische Explosion
gibt. Das ist aber nicht der Fall, da vor Auslieferung von Gerät+Linux-Image
dies sowieso von FAE und Kunden geprüft und dann in einer spezifischen
Hardware/Softwareversion freigegeben und festgezurrt wurde)</li></ul></div></div><div id=outline-container-headline-3 class=outline-3><h3 id=headline-3>Basis: Debian-Linux</h3><div id=outline-text-headline-3 class=outline-text-3><p>Basis war Debian-Linux.</p><p>Heutzutage ist Ubuntu viel bekannter, aber bei Projektstart war dies nicht der
Fall. Außerdem ist Ubuntu auf das Desktop-Metapher optimiert. In
Industrie-Anwendungen will man aber z.B. keinen Start-Button haben. Man möchte
(i.d.R.) nicht, das beim Einstecken eines USB-Sticks ein Dialog aufpoppt. Im
Prinzip braucht man überhaupt nichts aus der Desktop-Metapher.</p><p>Stattdessen möchte man fast immer nur einige einzige Anwendung haben, exclusiv,
im "Kiosk-Modus". Also nicht abbrechbar und ohne Wechselmöglichkeit. Also warum
ein Icon haben, das man anklicken muss, wenn die Applikation auch direkt
gestartet werden kann?</p><p>Schließlich will niemand, das Lagerarbeiter Tetris spielen …</p></div></div><div id=outline-container-headline-4 class=outline-3><h3 id=headline-4>Anpassen … aber an was?</h3><div id=outline-text-headline-4 class=outline-text-3><p>Die unterstützten Geräte (siehe unten) habe unterschiedliche …</p><ul><li>Anzahl Ethernet-Karten: 0 bis 2</li><li>Anzahl WLAN-Karten: 0 bis 1</li><li>Anzahl WWAN-Karten (GSM, UMTS etc): 0 bis 1</li><li>Anzahl NFC-Interfaces: 0 bis 1</li><li>Anzahl Bluetooth-Interfaces: 0 bis 1</li><li>unterschiedliche Auflösungen</li><li>unterschiedliche Tasten auf der Frontplatte</li><li>unterschiedliche Touchscreen-Technologien (resistiv, kapazitiv) und Touchscreen-Controller-ICs</li><li>unterschiedliche Beleuchtungskonzepte (Backlight, Keyboard …)</li><li>unterschiedliche Barcode-Scanner (keine, Symbol, Intermec, Honeywell, seriell, Bluetooth)</li><li>… und viele Unterschiede mehr</li></ul><p>Jedoch sollte die Software im "Combined-Linux" Image sich dynamisch auf die
Gegenheiten anpassen, beispielsweise welche Einstellungsmöglichkeit im
"<code class=verbatim>config</code>" GUI-Programm angezeigt werden.</p><p>Hier Beispiele für die Geräteklassen:</p><div id=outline-container-headline-5 class=outline-4><h4 id=headline-5>Stapler-Terminals</h4><div id=outline-text-headline-5 class=outline-text-4><p><img src=./staplerterminals.jpg alt=./staplerterminals.jpg title=./staplerterminals.jpg></p><ul><li>IPC7 (DLoG)</li><li>MPC6 (DLoG)</li><li>MTC6 (DLoG)</li><li>MTC6 mit AMD CPU</li><li>DLT-V83 (DLoG)</li><li>DLT-V83 Atom (DLoG)</li><li>DLT-V83 Celeron (DLoG)</li><li>DLT-V83 Facelift (Advantech)</li><li>DLT-V83 i5 (DLoG)</li><li>DLT-V72 (DLoG)</li><li>DLT-V72 Facelift (Advantech)</li><li>DLT-V72 mit voller Tastatur (DLoG)</li><li>DLT-V73 x86 (Advantech)</li><li>DLT-V62 (Advantech)</li><li>DLT-M81 (Advantech)</li></ul><p>Werden in Stapler- oder Kommissionierfahrzeuge eingebaut. Manchmal auch in
Hochregal-Bedienfahrzeuge, Logistik-Hängebahnen, Portalkräne etc.</p></div></div><div id=outline-container-headline-6 class=outline-4><h4 id=headline-6>Tragbare Terminals</h4><div id=outline-text-headline-6 class=outline-text-4><p><img src=./handterminals.jpg alt=./handterminals.jpg title=./handterminals.jpg></p><ul><li>DT362 (Digital Research)</li><li>S10A (Advantech)</li><li>PWS-770 (Advantech)</li><li>PWS-870 (Advantech)</li></ul><p>Diese Geräte nimmt man in die Hand und kann sich damit frei bewegen. Auf den
Fotos sieht man das nicht, aber sie haben einen eingebauten Barcode-Scanner.</p></div></div><div id=outline-container-headline-7 class=outline-4><h4 id=headline-7>Fahrzeug-Computer</h4><div id=outline-text-headline-7 class=outline-text-4><p><img src=./fahrzeugcomputer.jpg alt=./fahrzeugcomputer.jpg title=./fahrzeugcomputer.jpg></p><ul><li>TREK-753 (Advantech)</li></ul><p>Diese sind dazu gedacht, in KFZ eingebaut zu werden, beispielsweise in Bussen,
als Steuergerät für "Vehicle Smart Displays". Aber mit Linux drauf kann man sie
auch für andere Dinge einsetzen …</p></div></div><div id=outline-container-headline-8 class=outline-4><h4 id=headline-8>Industrie-Panel-PCs</h4><div id=outline-text-headline-8 class=outline-text-4><p><img src=./panelpcs.jpg alt=./panelpcs.jpg title=./panelpcs.jpg></p><ul><li>UTC-210 (Advantech)</li><li>UTC-520 (Advantech)</li></ul><p>Werden in der Industrie zum Anzeigen allgemeiner Informationen genutzt,
beispielsweise an den Fließbändern von Auto-Herstellern.</p></div></div></div></div><div id=outline-container-headline-9 class=outline-3><h3 id=headline-9>Hardware erkennen</h3><div id=outline-text-headline-9 class=outline-text-3><p>Man muß nun den Gerätetyp einwandfrei erkennen. Wie macht man das am besten, damit
man keine Falscherkennungen hat?</p><div class="src src-dot"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>digraph G {
</span></span><span style=display:flex><span>        &#34;BIOS Strings&#34; -&gt; kmod;
</span></span><span style=display:flex><span>        &#34;DMI Data&#34; -&gt; kmod;
</span></span><span style=display:flex><span>        &#34;PCI IDs&#34;-&gt; kmod;
</span></span><span style=display:flex><span>        kmod -&gt; proc [style=dotted];
</span></span><span style=display:flex><span>        proc -&gt; &#34;config GUI&#34;;
</span></span><span style=display:flex><span>        proc -&gt; &#34;configwriter&#34;;
</span></span><span style=display:flex><span>        proc -&gt; &#34;wlanmonitor&#34;;
</span></span><span style=display:flex><span>        proc -&gt; &#34;scannerd&#34;;
</span></span><span style=display:flex><span>        proc -&gt; &#34;...&#34;;
</span></span><span style=display:flex><span>        kmod [shape=box; label=&#34;Kernel module&#34;];
</span></span><span style=display:flex><span>        proc [shape=box; label=&#34;Pseudo-file in /proc&#34;];
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><div id=outline-container-headline-10 class=outline-4><h4 id=headline-10>String im BIOS</h4><div id=outline-text-headline-10 class=outline-text-4><p>Die von DLoG oder Advantech (sie haben DLoG aufgekauft) selbst produzierten Geräte
hatten im BIOS einen speziell formatieren String hinterlegt. Der hat das Gerät,
aber auch die Version des BIOS kodiert.</p><p>Eine Wildcard-Suche prüfte dann in einem definierten physikalischen Speicherbereich, ob
es einen String wie z.B. "M6I??C??" gibt.</p><p>Das hat ein Linux-Kernel-Modul gemacht, da hierbei einfach auf physikalischen
Speicher zugegriffen werden kann. Ein Linux-Userspace-Programm kann das zwar
auch, müsste aber als "root" laufen.</p><pre class=example>
  // Mem start, length,  Wildcard + len, Device,  Human text
  { 0x000f0000, 0xffffe, &#34;G6I??C??&#34;,  8, IS_DEVA, &#34;Device A&#34; },
  { 0xfff40000, 0x80000, &#34;G6A??C??&#34;,  8, IS_DEVB, &#34;Device A mit AMD&#34; },
</pre><p>Das Kernelmodul wird automatisch geladen und stellt sein Ergebnis via
"<code class=verbatim>/proc/...</code>" Pseudo-Datei zur Verfügung. Darauf können alle Programme
zugreifen, "root" oder nicht.</p><p>Bei den Geräten, die einen BIOS-String haben, kamen wir auf 100% Erkennungsrate
und 0% Fehlerrate.</p></div></div><div id=outline-container-headline-11 class=outline-4><h4 id=headline-11>DMI</h4><div id=outline-text-headline-11 class=outline-text-4><p>Leider gab es Hardware, bei der das nicht funktionierte: Geräte die nicht unter den
Einfluss von DLoG designed wurden (beispielsweise die Treks, die UTCs, die PWS).</p><p>Aber in einigen Fällen sind die Informationen des <a href=https://de.wikipedia.org/wiki/Desktop_Management_Interface>DMI</a> brauchbar. Als Kernel-Modul kommt
man da recht einfach dran:</p><div class="src src-c"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>  vendor  <span style=color:#f92672>=</span> <span style=color:#a6e22e>dmi_get_system_info</span>(DMI_SYS_VENDOR);
</span></span><span style=display:flex><span>  product <span style=color:#f92672>=</span> <span style=color:#a6e22e>dmi_get_system_info</span>(DMI_PRODUCT_NAME);</span></span></code></pre></div></div><p>Das Ergebnis kann man gegen Soll-Werte vergleichen und weiß dann, auf welcher Hardware
man ist.</p><p>Bei den Geräten, die einen DMI-String haben, kamen wir auf 100% Erkennungsrate
und 0% Fehlerrate.</p></div></div><div id=outline-container-headline-12 class=outline-4><h4 id=headline-12>PCI-IDs testen</h4><div id=outline-text-headline-12 class=outline-text-4><p>Erstaunlicherweise gibt es viel DMIs, die schlecht gepflegt sind. Da steht dann
z.B. "to be filled by O.E.M.", womit man nichts anfangen kann. Außer vielleicht
darauf schließen, das der Hersteller keine Liebe zum Detail hat und
unvollständige Arbeit abliefert.</p><p>Man braucht als leider eine Rückfalloption. Dazu dienten PCI-IDs. Im Linux-Userspace
kann man diese mit "<code class=verbatim>lspci -nn</code>" sehen — und selbstverständlich kommt ein</p><pre class=example>
  // Host bridge
  { 0x8086, 0x0a04, IS_DEVA | IS_DEVB },           // Intel Corporation Haswell-ULT DRAM Controller
  { 0x8086, 0x0bf1, IS_DEVC },                     // Intel Corporation Atom Processor D2xxx DRAM Controller
  { 0x8086, 0x0f00, IS_DEVD | IS_DEVE | IS_DEVF},  // Intel Corporation Atom Processor Z36xxx/Z37xxx Series SoC

  // PCI Bridge
  ...

  // SATA
  ...

  // USB-Controller
  ...
</pre><p>Wie man gut sieht, reicht die Host-Bridge 8086:0a04 nicht aus, um ein Gerät
eindeutig zu indentifizieren. Denn sie kommt auf mehreren Geräten vor.</p><p>Wenn man jedoch die Informationen der anderen PCI-IDs hinzufügt (mit "…"
angedeutet), klappt es evtl doch.</p><p>Damit konnte ich dann die Hardware-Erkennung für all die Geräte "erschlagen",
die weder BIOS-Strings noch DMI-Strings hatten. Jedoch … wird das Image auf
einem unbekanntem Gerät ausgeführt, kann es Fehlerkennungen geben.</p></div></div></div></div><div id=outline-container-headline-13 class=outline-3><h3 id=headline-13>Userspace</h3><div id=outline-text-headline-13 class=outline-text-3><div id=outline-container-headline-14 class=outline-4><h4 id=headline-14>GUI anpassen</h4><div id=outline-text-headline-14 class=outline-text-4><p>Nachdem die Hardware einmal erkannt ist, ist es leicht, darauf zu reagieren.</p><p>Das "<code class=verbatim>config</code>" GUI ist in C++/Qt geschrieben.</p><p>Darauf aufsetzend wurden Funktionen definiert die mit "<code class=verbatim>isXXX()</code>" bzw "<code class=verbatim>hasXXXX()</code>"
anfangen. Die is-Funktionen prüfen auf eine Gerät, die has-Funktionen prüfen
auf eine Funktion (hat Bluetooth, hat Backlight, hat USB-Gerät XXXX:YYYY).</p><p>Dadurch ist das Anpassen, hier z.B. des grafischen Menüs, ziemlich einfach:</p><pre class=example>
    if (isDevA() || isDevE() || isDemo())
        addIcon(tr(&#34;Backlight&#34;), &#34;:/images/backlight.svg&#34;, SLOT(clickedBacklight()) );
</pre></div></div><div id=outline-container-headline-15 class=outline-4><h4 id=headline-15>Daemons anpassen</h4><div id=outline-text-headline-15 class=outline-text-4><p>Auch Daemons müssen sich an die sehr unterschiedlicher Hardware anpassen. Dort
geht dies genauso einfach, hier am Beispiel des "<code class=verbatim>scannerd</code>":</p><pre class=example>
    if (isDevA()) {
        port = &#34;/dev/ttyS1&#34;;
        serialReader = new ReadIntermec(port, 19200, this);
        serialReconnect = true;
    } else
    if (isDevE()) {
        port = &#34;/dev/ttyS1&#34;;
        serialReader = new ReadHoneywell(port, 115200, this);
        serialReconnect = true;
    } else
</pre></div></div></div></div><div id=outline-container-headline-16 class=outline-3><h3 id=headline-16>Verwandte Projekte</h3><div id=outline-text-headline-16 class=outline-text-3><p>Die folgenden Projekte verwenden (teils abgewandelt) das Combined Image:</p><ul><li></li><li></li><li></li><li>TODO(Artikel schreiben) Linux Restore Stick</li><li></li><li>TODO(Artikel schreiben) Hardware-Teststick für DLT-V73</li><li>TODO(Artikel schreiben) Aufräumen in Fukushima</li></ul></div></div></div></div><div class=post-meta><div><i class="fa fa-copyright fa-fw"></i>
License: <a href=https://spdx.org/licenses/CC-BY-SA-4.0.html target=_blank>CC-BY-SA 4.0</a></div><div><i class="fa fa-calendar fa-fw"></i>
<time>0001-01-01</time></div></div></div></div></div><script src=../../../js/ui.js></script><script src=../../../js/menus.js></script></body></html>