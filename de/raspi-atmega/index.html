<!doctype html><html lang=en><head><meta name=generator content="Hugo 0.82.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta property="og:title" content="ATmega328 von Raspberry aus programmieren"><meta name=keywords content="RasPi,Arduino,ATmega,SPI"><meta property="og:title" content="ATmega328 von Raspberry aus programmieren"><meta property="og:description" content="Viele Leute kennen den ATmega von den Arduino-Projekten. Dort sind die
Prozessoren bereits mit einem sog. &lsquo;Bootloader&rsquo; versehen, man kann sie
also über deren serielle Schnittstelle programmieren.
Was aber, wenn man einen &ldquo;rohen&rdquo; ATmega hat, frisch vom
Elektronikladen? Und außerdem kein AVR-Programmiergerät? Dann nimmt
man eben des Raspberry zum Programmieren!"><meta property="og:type" content="article"><meta property="og:url" content="http://holgerschurig.github.io/de/raspi-atmega/"><meta property="article:section" content="de"><meta property="article:published_time" content="2016-03-28T17:48:46+02:00"><meta property="article:modified_time" content="2016-03-28T17:48:46+02:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="ATmega328 von Raspberry aus programmieren"><meta name=twitter:description content="Viele Leute kennen den ATmega von den Arduino-Projekten. Dort sind die
Prozessoren bereits mit einem sog. &lsquo;Bootloader&rsquo; versehen, man kann sie
also über deren serielle Schnittstelle programmieren.
Was aber, wenn man einen &ldquo;rohen&rdquo; ATmega hat, frisch vom
Elektronikladen? Und außerdem kein AVR-Programmiergerät? Dann nimmt
man eben des Raspberry zum Programmieren!"><link rel=icon type=image/png href=../../favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=../../favicon-16x16.png sizes=16x16><link rel=stylesheet type=text/css media=screen href=../../css/normalize.css><link rel=stylesheet type=text/css media=screen href=../../css/main.css><link rel=stylesheet type=text/css media=screen href=../../css/all.css><link rel=stylesheet href=../../css/katex.min.css crossorigin=anonymous><script defer src=../../js/katex.min.js integrity=sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz crossorigin=anonymous></script><script defer src=../../js/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body)></script><title>ATmega328 von Raspberry aus programmieren | Holger Schurig's Computer Calisthenics & Orthodontia</title></head><body><header><div id=avatar><a href=http://holgerschurig.github.io/><img src=../../img/vitae.jpg alt="Holger Schurig's Computer Calisthenics & Orthodontia"></a></div><div id=titletext><h2 id=title><a href=http://holgerschurig.github.io/>Holger Schurig's Computer Calisthenics & Orthodontia</a></h2></div><div id=title-description><p id=subtitle></p><div id=social><nav><ul><li><a href=../../index.xml><i title=RSS class="icons fas fa-rss"></i></a></li></ul></nav></div></div><div id=mainmenu><nav><ul><li><a href=../../en>English</a></li><li><a href=../../de>Deutsch</a></li><li><a href=../../tags>Tags</a></li><li><a href=../../topics>Topics</a></li><li><a href=../../impressum>Impressum</a></li></ul></nav></div></header><main><div class=post><div class=author></div><div class=post-header><div class=meta><div class=date><span class=day>28</span>
<span class=rest>Mar 2016</span></div></div><div class=matter><h1 class=title>ATmega328 von Raspberry aus programmieren</h1></div></div><div class=markdown><p>Viele Leute kennen den ATmega von den Arduino-Projekten. Dort sind die
Prozessoren bereits mit einem sog. &lsquo;Bootloader&rsquo; versehen, man kann sie
also über deren serielle Schnittstelle programmieren.</p><p>Was aber, wenn man einen &ldquo;rohen&rdquo; ATmega hat, frisch vom
Elektronikladen? Und außerdem kein AVR-Programmiergerät? Dann nimmt
man eben des Raspberry zum Programmieren!</p><p>In der Zeitschrift &ldquo;Funkamateur 2/2016&rdquo; ist ein ähnlicher Artikel
enthalten. Aber der dort getriebene Aufwand ist wesentlich höher.
Beispielsweise wird ein Darlington-Array <code>ULN2803</code> gebraucht, und die
Programmierung erfolgt auch nicht (auf Raspberry-Seite) über SPI und
einem Standardprogramm, sondern über GPIOs und einem Python-Programm.</p><h2 id=schaltung>Schaltung</h2><p>Die Grundschaltung eines ATmega328 ist einfach:</p><ul><li><code>VCC</code> (Pin 7) mit 3.3V verbinden. Theoretisch sollte man noch <code>AVCC</code>
(Pin 20) mit 3.3V verbinden, zum Programmieren brauchte ich das aber
nicht.</li><li><code>GND</code> (Pin 8) mit Masse verbinden. Theoretisch sollte man auch noch das
andere <code>GND</code> (Pin 22) mit Masse verbinden. Bei mir war das aber zum
Programmieren nicht nötig.</li><li>ein Kondensator <code>C1</code> mit 100nF als Abblockkondensator nahe an Pins 7
und 8.</li><li>16 MHz-Quarz an Pins 9 und 10</li><li>von jedem Quarz-Pin ein 22pF Kondensator nach Masse führen</li><li><code>nRESET</code> über einen Pull-Up-Widerstand von 10 kOhm nach <code>VCC</code>. Später
merkte ich, das noch nicht mal der Pull-Up-Widerstand wirklich nötig
ist &mldr;</li></ul><p>Obige Grundschaltung findet man immer und immer wieder.</p><p>Nun wollen wir den ATmega jedoch programmieren, also müssen wir einige
Bahnen vom Raspberry zum ATmega ziehen:</p><ul><li>gelb: <code>GPIO25</code> nach <code>nRESET</code></li><li>cyan: <code>GPIO10</code>/<code>SPI0_MOSI</code> nach <code>D11</code>/<code>MOSI</code></li><li>lila: <code>GPIO9</code>/<code>SPI0_MISO</code> nach <code>D12</code>/<code>MISO</code></li><li>grün: <code>GPIO11</code>/<code>SPI_CLK</code> nach <code>D13</code>/<code>SCK</code></li></ul><p>Die erste (gelbe) Leitung ist zum Resetten des ATmega.</p><p>Die anderen drei Leitungen sind SPI-Leitungen, mit denen der Raspberry
den AVR programmieren kann.</p><h2 id=software>Software</h2><h3 id=avrdude-installieren>AVRdude installieren</h3><p>Auf dem Raspberry brauchen wir die Software <code>avrdude</code>:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>pi<span style=color:red;background-color:#faa>@</span>raspberrypi:<span style=color:red;background-color:#faa>~</span> <span style=color:red;background-color:#faa>$</span> sudo su
root<span style=color:red;background-color:#faa>@</span>raspberrypi:<span style=color:#333>/</span>home<span style=color:#333>/</span>pi<span style=color:red;background-color:#faa>#</span> apt<span style=color:#333>-</span>get install avrdude
Reading <span style=color:#080;font-weight:700>package</span> lists<span style=color:#333>...</span> Done
Building dependency tree       
Reading state information<span style=color:#333>...</span> Done
The following extra packages will be installed:
  libftdi1
Suggested packages:
  avrdude<span style=color:#333>-</span>doc
The following NEW packages will be installed:
  avrdude libftdi1
<span style=color:#00d;font-weight:700>0</span> upgraded, <span style=color:#00d;font-weight:700>2</span> newly installed, <span style=color:#00d;font-weight:700>0</span> to remove and <span style=color:#00d;font-weight:700>12</span> not upgraded.
Need to get <span style=color:#00d;font-weight:700>260</span> kB of archives.
After this operation, <span style=color:#00d;font-weight:700>1</span>,<span style=color:#40e;font-weight:700>021</span> kB of additional disk space will be used.
Do you want to <span style=color:#080;font-weight:700>continue</span><span style=color:red;background-color:#faa>?</span> [Y<span style=color:#333>/</span>n] y
Get:<span style=color:#00d;font-weight:700>1</span> http:<span style=color:#888>//archive.raspberrypi.org/debian/ jessie/main avrdude armhf 6.1-2+rpi1 [244 kB]
</span><span style=color:#888></span>Get:<span style=color:#00d;font-weight:700>2</span> http:<span style=color:#888>//mirrordirector.raspbian.org/raspbian/ jessie/main libftdi1 armhf 0.20-2 [16.7 kB]
</span><span style=color:#888></span>Fetched <span style=color:#00d;font-weight:700>260</span> kB in <span style=color:#00d;font-weight:700>1</span><span style=color:#06b;font-weight:700>s</span> (<span style=color:#00d;font-weight:700>182</span> kB<span style=color:#333>/</span>s)                              
Selecting previously unselected <span style=color:#080;font-weight:700>package</span> libftdi1:armhf.
(Reading database <span style=color:#333>...</span> <span style=color:#00d;font-weight:700>126952</span> files and directories currently installed.)
Preparing to unpack <span style=color:#333>.../</span>libftdi1_0<span style=color:#60e;font-weight:700>.20</span><span style=color:#333>-</span><span style=color:#00d;font-weight:700>2</span>_armhf.deb <span style=color:#333>...</span>
Unpacking libftdi1:<span style=color:#06b;font-weight:700>armhf</span> (<span style=color:#60e;font-weight:700>0.20</span><span style=color:#333>-</span><span style=color:#00d;font-weight:700>2</span>) <span style=color:#333>...</span>
Selecting previously unselected <span style=color:#080;font-weight:700>package</span> avrdude.
Preparing to unpack <span style=color:#333>.../</span>avrdude_6<span style=color:#60e;font-weight:700>.1</span><span style=color:#333>-</span><span style=color:#00d;font-weight:700>2</span><span style=color:#333>+</span>rpi1_armhf.deb <span style=color:#333>...</span>
Unpacking <span style=color:#06b;font-weight:700>avrdude</span> (<span style=color:#60e;font-weight:700>6.1</span><span style=color:#333>-</span><span style=color:#00d;font-weight:700>2</span><span style=color:#333>+</span>rpi1) <span style=color:#333>...</span>
Processing triggers <span style=color:#080;font-weight:700>for</span> man<span style=color:#333>-</span><span style=color:#06b;font-weight:700>db</span> (<span style=color:#60e;font-weight:700>2.7.0.2</span><span style=color:#333>-</span><span style=color:#00d;font-weight:700>5</span>) <span style=color:#333>...</span>
Setting up libftdi1:<span style=color:#06b;font-weight:700>armhf</span> (<span style=color:#60e;font-weight:700>0.20</span><span style=color:#333>-</span><span style=color:#00d;font-weight:700>2</span>) <span style=color:#333>...</span>
Setting up <span style=color:#06b;font-weight:700>avrdude</span> (<span style=color:#60e;font-weight:700>6.1</span><span style=color:#333>-</span><span style=color:#00d;font-weight:700>2</span><span style=color:#333>+</span>rpi1) <span style=color:#333>...</span>
Processing triggers <span style=color:#080;font-weight:700>for</span> libc<span style=color:#333>-</span><span style=color:#06b;font-weight:700>bin</span> (<span style=color:#60e;font-weight:700>2.19</span><span style=color:#333>-</span><span style=color:#00d;font-weight:700>18</span><span style=color:#333>+</span>deb8u3) <span style=color:#333>...</span>
</code></pre></div><p>Ältere Tutorials reden davon, das man den AVRdude selbst compilieren
solle. Das ist aber mittlerweile nicht mehr nötig. Mein Raspberry
läuft Raspian 8.0, also basierend auf Debian Jessie. Und die
avrdude-Version <strong>6.1</strong> funktioniert einwandfrei.</p><h3 id=chip-erkennen>Chip erkennen</h3><p>Hat man alles richtig verdrahtet, sollte der Chip erkannt werden:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>root@raspberrypi:~# avrdude -c linuxspi -p m328p -P /dev/spidev0.0 
avrdude: AVR device initialized and ready to accept instructions
Reading | ################################################## | 100% 0.00s
avrdude: Device signature = 0x1e950f
avrdude: safemode: Fuses OK (E:07, H:D9, L:62)
avrdude done.  Thank you.
</code></pre></div><p>Die Device-Signatur 0x1e950f steht für den ATmega328<strong>P</strong>, also exakt
für den Chip, den ich mir gekauft hatte.</p><p>Sollte kein <code>/dev/spidev0.0</code> vorhanden sein, muss <code>raspi-config</code>
starten und unter &ldquo;Advanced Options&rdquo; SPI aktivieren.</p><h3 id=takt-senken>Takt senken</h3><p>Bei mir ging es danach aber dennoch noch nicht. Erst als ich den
SPI-Takt von 400 kHz auf 200 kHz gesenkt hatte, lief es. Das ist zwar
deutlich langsamer als vorher, aber immer noch schneller als mit
GPIO-&ldquo;Bitbanging&rdquo;.</p><p>Dazu in <code>/etc/avrdude.conf</code> den Eintrag <code>linuxspi</code> so ändern:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>programmer
  id = &#34;linuxspi&#34;;
  desc = &#34;Use Linux SPI device in /dev/spidev*&#34;;
  type = &#34;linuxspi&#34;;
  reset = 25;
  baudrate=200000;
;
</code></pre></div><p>Nun hat&rsquo;s funktioniert. Ich vermute, das meine Kabel vom Raspberry zum
Breadboard mit dem ATmega zu lang waren.</p></div><div class=tags><div class=taxosfloating_left><p>Tags</p></div><div class=termsfloating_right><p><a href=../../tags/arduino/>arduino</a>
<a href=../../tags/atmega/>atmega</a>
<a href=../../tags/raspi/>raspi</a>
<a href=../../tags/spi/>spi</a></p></div><div class=clearit></div><div class=tags><div class=taxosfloating_left><p>Topics</p></div><div class=termsfloating_right><p><a href=../../topics/elektronik/>elektronik</a></p></div><div class=clearit></div></div></div></main></body></html>