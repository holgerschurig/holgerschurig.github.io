<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=generator content="Hugo 0.124.1"><title>&#183; Holger Schurig's Computer Calisthenics & Orthodontia</title>
<link rel=stylesheet href=../../../css/pure-min.css><!--[if lte IE 8]><link rel=stylesheet href=../../../css/grids-responsive-old-ie-min.css><![endif]--><!--[if gt IE 8]><!--><link rel=stylesheet href=../../../css/grids-responsive-min.css><!--<![endif]--><!--[if lte IE 8]><link rel=stylesheet href=../../../css/side-menu-old-ie.css><![endif]--><!--[if gt IE 8]><!--><link rel=stylesheet href=../../../css/side-menu.css><!--<![endif]--><link rel=stylesheet href=../../../css/blackburn.css><link rel=stylesheet href=../../../css/all.min.css><link rel=alternate type=application/rss+xml title="Holger Schurig's Computer Calisthenics & Orthodontia" href=../../../index.xml><link rel="shortcut icon" href=../../../img/favicon.ico type=image/x-icon></head><body><div id=layout><a href=#menu id=menuLink class=menu-link><span></span></a><div id=menu><div class=pure-menu><ul class=pure-menu-list><li class=pure-menu-item><a class=pure-menu-link href=../../../><i class='fa fa-home fa-fw'></i>Home</a></li><li class=pure-menu-item><a class=pure-menu-link href=../../../en/><i class='fa fa-list fa-fw'></i>Articles</a></li><li class=pure-menu-item><a class=pure-menu-link href=../../../de/><i class='fa fa-list fa-fw'></i>Beiträge</a></li><li class=pure-menu-item><a class=pure-menu-link href=../../../categories/><i class='fa fa-folder fa-fw'></i>Categories</a></li><li class=pure-menu-item><a class=pure-menu-link href=../../../tags/><i class='fa fa-tags fa-fw'></i>Tags</a></li><li class=pure-menu-item><a class=pure-menu-link href=../../../impressum/><i class='fa fa-phone fa-fw'></i>Impressum</a></li></ul></div></div><div id=main><div class=header><h1></h1><h2></h2></div><div class=content><div id=outline-container-headline-1 class=outline-2><h2 id=headline-1>Dynamischer Flash-Schutz</h2><div id=outline-text-headline-1 class=outline-text-2><p>Hier geht es darum, wie man den Flash-Speicher vor Wear-Out schützen kann,
ohne die Usability allzu sehr einzuschränken.</p><nav><ul><li><a href=#headline-1>Dynamischer Flash-Schutz</a><ul><li><a href=#headline-2>Projekt-Info</a></li><li><a href=#headline-3>Warum muss Flash geschützt werden?</a></li><li><a href=#headline-4>Lösungsansätze</a></li><li><a href=#headline-8>Flash-Schutz am Beispiel</a></li><li><a href=#headline-13>Verwandte Projekte</a></li></ul></li></ul></nav><div class=job-block><p>In Beiträgen der Kategorie <a href=../../../categories/job/>Job</a> trage ich Projekte zusammen, die ich im Rahmen
meiner beruflichen Karriere federführend durchgeführt habe. Ich gehe dabei mit
Absicht nicht allzu sehr auf Details an: die Interessen meiner Arbeitgeber sollen
ja nicht berührt werden.</p></div><div id=outline-container-headline-2 class=outline-3><h3 id=headline-2>Projekt-Info</h3><div id=outline-text-headline-2 class=outline-text-3><p>Idee & Umsetzung: ich</p><p>Projektdauer: 2012 bis heute</p><p>Effizienzgewinn:</p><ul><li>das Filesystem bleibt auf den Kundengeräten über Jahre intakt</li><li>hebt die Kundenzufriedenheit deutlich — nichts ist frustiger als ein Kunde,
bei dem die auf Akkord arbeitenden Mitarbeiter Zwangspausen haben, weil man
erst die CFast-Karte wechseln muss</li><li>Ausbrechen aus dem Flash-Schutz jederzeit ohne Reboot möglich — wenn man
weiss, wie :-)</li></ul></div></div><div id=outline-container-headline-3 class=outline-3><h3 id=headline-3>Warum muss Flash geschützt werden?</h3><div id=outline-text-headline-3 class=outline-text-3><p>Flash hat generell eine begrenzte Anzahl von Schreibzyklen. <a href=https://de.wikipedia.org/wiki/Flash-Speicher#Vor-_und_Nachteile>Wikipedia</a>
beispielsweise schreibt "Bei übermäßiger Nichtbenutzung und bei qualitativ
minderwertigen Flash-Datenträgern könnte der Verlust elektrischer Ladung in den
Transistoren Daten in Sektoren beschädigen.".</p><p>Was aber ist eine "übermäßige Nutzung"? Das kann bereits das Log-File sein, in
das z.B. Java-Programmierer geradezu verliebt sind. Jede ausgegebene Zeile
erzeugt diese Aktionen auf Filesystem-Ebene:</p><ul><li>schreiben eines oder mehrere Datenblocks (wenn die Zeile eine Blockgrenze überschreitet)</li><li>Update des Directory-Eintrages (Filelänge, Zeitstempel letzter Zugriff)</li><li>u.U. Update des inode-Daten (wenn ein neuer Block alloziert werden muss)</li></ul><p>Über 365 Tage mal 8 Stunden Schicht … passiert da recht viel.</p></div></div><div id=outline-container-headline-4 class=outline-3><h3 id=headline-4>Lösungsansätze</h3><div id=outline-text-headline-4 class=outline-text-3><div id=outline-container-headline-5 class=outline-4><h4 id=headline-5>Losungsansatz Windows</h4><div id=outline-text-headline-5 class=outline-text-4><p>Windows selbst hatte damals keine Lösung.</p><p>Aber Windows Embedded hatte einen Modus, in dem man die Partition auf "read-only" setzen
konnte. Das bedeutete aber einen Reboot — was unter Windows Embedded 7 eine Ewigkeit dauerte.
Auch musste die Applikation damit klarkommen.</p><p>Auch Windows EWF bedingte (idealerweise), das die Anwendung sich dessen bewusst ist.</p><p>In der Praxis sorgte dies dafür, das man ohne lange Wartezeiten keine Änderungen am Image
machen konnte, noch nicht mal die IP-Adresse war zu ändern.</p></div></div><div id=outline-container-headline-6 class=outline-4><h4 id=headline-6>Lösungsansatz Android</h4><div id=outline-text-headline-6 class=outline-text-4><p>Unter Android gibt es viele, viele Partitionen. Oft über 20 oder 30. Einige
davon kann man als Systempartitionen ansehen: sie sind komplett read-only. Ein
Umschalten in den beschreibbaren Modus ist für Endkunden nicht vorgesehen -> man
ist dem Hersteller ausgeliefert.</p><p>Netterweise gibt es auch Partitionen, die beschreibbar sind. Dort wird ein Großteil
(aber nicht alles!) der Systemkonfiguration wie IP-Adresse abgespeichert.</p><p>Insbesondere die Update-Situation ist hier jedoch anzukreiden, eine Kopie dieses
Verfahrens wird nicht empfohlen.</p></div></div><div id=outline-container-headline-7 class=outline-4><h4 id=headline-7>Lösungsansatz "Combined Linux"</h4><div id=outline-text-headline-7 class=outline-text-4><p>Unter Linux gibt es sog. "Union Filesystems". Früher nur <a href=https://aufs.sourceforge.net/>AUFS</a> (Another Union
Filesystem), heute auch <a href=https://unionfs.filesystems.org/>UnionFS</a>.</p><p>Hierbei hat man zwei Partitionen, die übereinander gelegt werden. In die obere
Partition (das Flash) wird nie geschrieben, von dort wird nur gelesen. Darüber
gelegt ist eine RAM-Disk. Schreibvorgänge werden dorthin umgeleitet. Wird
gelesen, schaut AUFS zunächst in der RAM-Disk nach. Steht dort die Datei,
bekommt man sie auch. Steht sie dort noch nicht, wird sie aus dem Flash gelesen.
In der RAM-Disk passiert dabei nichts.</p></div></div></div></div><div id=outline-container-headline-8 class=outline-3><h3 id=headline-8>Flash-Schutz am Beispiel</h3><div id=outline-text-headline-8 class=outline-text-3><div id=outline-container-headline-9 class=outline-4><h4 id=headline-9>Lesevorgang</h4><div id=outline-text-headline-9 class=outline-text-4><p>Nehmen wir mal ein Programm, welches den Nameserver wissen will — unter Linux übernimmt
das normalerweise die GNU C Library, sie liest "<code class=verbatim>/etc/resolv.conf</code>". Was passiert bei einem
frisch gebooteten System?</p><p>Beim Flash ist ein Default-Nameserver hinterlegt:</p><table><thead><tr><th>Ort</th><th>Datei</th><th>Inhalt bei Lesen</th></tr></thead><tbody><tr><td>Flash</td><td>/etc/resolv.conf</td><td>nameserver 4.4.4.4</td></tr><tr><td>RAM-Disk</td><td>&lt;existiert nicht></td><td>nameserver 4.4.4.4</td></tr></tbody></table><p>Wenn nun ein Programm auf "<code class=verbatim>/etc/resolv.conf</code>" zugreift, bekommt es den
4.4.4.4er Nameserver. Denn in der RAM-Disk existiert kein Eintrag.</p></div></div><div id=outline-container-headline-10 class=outline-4><h4 id=headline-10>Schreibvorgang</h4><div id=outline-text-headline-10 class=outline-text-4><p>Nach dem Boot wird oft ein DHCP-Client gestartet. Er holt sich (u.A.) die
IP-Adresse und den Nameserver ab — in diesem Beispiel eine Adresse aus dem
172.16er Netzwerk. Der Nameserver wird dann nach "<code class=verbatim>/etc/resolv.conf</code>"
geschrieben.</p><p>Der Zustand ist nun so:</p><table><thead><tr><th>Ort</th><th>Datei</th><th>Inhalt bei Lesen</th></tr></thead><tbody><tr><td>Flash</td><td>/etc/resolv.conf</td><td>nameserver 4.4.4.4</td></tr><tr><td>RAM-Disk</td><td>/etc/resolv.conf</td><td>nameserver 172.16.1.1</td></tr></tbody></table><p>Wenn nun ein Programm auf "<code class=verbatim>/etc/resolv.conf</code>" zugreift, bekommt es den
172.16.1.1er Nameserver.</p><p>Das Flash wurde <strong>nicht</strong> geändert. Das bedeutet übrigens auch: wenn man nun das
Gerät aus- und wieder einschaltet (oder rebootet), dann sind sämtliche
Änderungen am Filesystem wieder vergessen.</p></div></div><div id=outline-container-headline-11 class=outline-4><h4 id=headline-11>Flash ändern</h4><div id=outline-text-headline-11 class=outline-text-4><p>Bei dem bisher beschriebenem System könnte man den Nameserver im Flash nie
ändern. Das ist ein wenig suboptimal: wenn der Kunde von DHCP auf statische
IP-Adressen umstellen wollte, hätte er Pech.</p><p>Allerdings habe ich oben ein wenig geschummelt und — der Didaktik wegen —
ein Detail ausgelassen: das Flash ist direkt per "<code class=verbatim>/media/realroot</code>" zu erreichen.
Eigentlich müsste der Zustand nach dem Booten also so aussehen:</p><table><thead><tr><th>Ort</th><th>Datei</th><th>Inhalt bei Lesen</th></tr></thead><tbody><tr><td>Flash</td><td>/media/realroot/etc/resolv.conf</td><td>nameserver 4.4.4.4</td></tr><tr><td>RAM-Disk</td><td>/etc/resolv.conf (existiert aber nicht)</td><td>nameserver 4.4.4.4</td></tr></tbody></table><p>Das Dateisystem-Root "<code class=verbatim>/</code>" ist Flash(ro)+RAM-Disk(rw).</p><p>Das "echte Root" (des Flash-Speichers) ist read-write erreichbar über "<code class=verbatim>/media/realroot</code>".</p><p>Wenn wir nun auf statische IP-Adresse umstellen, ändern wir einfach statt
"<code class=verbatim>/etc/resolv.conf</code>" die Datei "<code class=verbatim>/media/realroot/etc/resolv.conf</code>":</p><table><thead><tr><th>Ort</th><th>Datei</th><th>Inhalt bei Lesen</th></tr></thead><tbody><tr><td>Flash</td><td>/media/realroot/etc/resolv.conf</td><td>nameserver 192.168.1.200</td></tr><tr><td>RAM-Disk</td><td>/etc/resolv.conf (existiert aber nicht)</td><td>nameserver 192.168.1.200</td></tr></tbody></table><p>Dies wurde nun im Flash geändert, nicht in der RAM-Disk. Da dort aber kein
eigenes "<code class=verbatim>/etc/resolv.conf</code>" existiert, wird das vom Flash durchgereicht.</p></div></div><div id=outline-container-headline-12 class=outline-4><h4 id=headline-12>Debian-Pakete installieren / chroot</h4><div id=outline-text-headline-12 class=outline-text-4><p>Man kann sogar im "echten" Root jederzeit Debian-Pakete installieren. Dafür müssen
wir einfach nur per "<code class=verbatim>chroot</code>" dort hineinwechseln:</p><div class="src src-sh"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>chroot /media/realroot</span></span></code></pre></div></div><p>Da aber "<code class=verbatim>dpkg</code>" bzw. "<code class=verbatim>apt-get</code>" Zugriff auf Linux-Devicenodes und
-Pseudodateien brauchen, führen wir einfach ein Bind-Mount durch:</p><div class="src src-sh"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>mount -o bind /dev     /media/realroot/dev
</span></span><span style=display:flex><span>mount -o bind /dev/pts /media/realroot/dev/pts
</span></span><span style=display:flex><span>mount -o bind /sys     /media/realroot/sys
</span></span><span style=display:flex><span>mount -o bind /proc    /media/realroot/proc
</span></span><span style=display:flex><span>debian_chroot<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;REALROOT&#34;</span> chroot /media/realroot /bin/bash -i
</span></span><span style=display:flex><span>umount /media/realroot/proc
</span></span><span style=display:flex><span>umount /media/realroot/sys
</span></span><span style=display:flex><span>umount /media/realroot/dev/pts
</span></span><span style=display:flex><span>umount /media/realroot/dev</span></span></code></pre></div></div><p>Ein Script namens "<code class=verbatim>in_realroot</code>" erledigt das schnell und einfach :-)</p></div></div></div></div><div id=outline-container-headline-13 class=outline-3><h3 id=headline-13>Verwandte Projekte</h3><div id=outline-text-headline-13 class=outline-text-3><p>Die folgenden Projekte verwenden den Flash-Schutz bzw. gehen auf ihn ein:</p><ul><li><p></p></li><li>TODO(Artikel schreiben) GUI Konfiguration: config + configwriter</li><li>TODO(Artikel schreiben) Image-Verteilung mit SSDP-Agent</li><li>TODO(Artikel schreiben) Linux-Image auf Basis von i.MX& RISC Prozessor für den Tagebau</li><li>TODO(Artikel schreiben) Linux Restore Stick</li><li>TODO(Artikel schreiben) Hardware-Teststick für DLT-V83/DLT-V72</li><li>TODO(Artikel schreiben) Hardware-Teststick für DLT-V73</li><li>TODO(Artikel schreiben) Aufräumen in Fukushima</li></ul></div></div></div></div><div class=post-meta><div><i class="fa fa-copyright fa-fw"></i>
License: <a href=https://spdx.org/licenses/CC-BY-SA-4.0.html target=_blank>CC-BY-SA 4.0</a></div><div><i class="fa fa-calendar fa-fw"></i>
<time>0001-01-01</time></div></div></div></div></div><script src=../../../js/ui.js></script><script src=../../../js/menus.js></script></body></html>